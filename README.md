# AutoLISP Blueprint 사용자 설명서

## 목차

1.  [소개](#1-소개)
2.  [초기 설정: API 키 등록](#2-초기-설정-api-키-등록)
3.  [인터페이스 둘러보기](#3-인터페이스-둘러보기)
4.  [핵심 개념: 다이어그램 제작](#4-핵심-개념-다이어그램-제작)
5.  [캔버스 사용법](#5-캔버스-사용법)
6.  [주요 기능 활용하기](#6-주요-기능-활용하기)
7.  [예제: 간단한 원 그리기 명령어 만들기](#7-예제-간단한-원-그리기-명령어-만들기)
8.  [자주 묻는 질문 (FAQ)](#8-자주-묻는-질문-faq)

---

## 1. 소개

### AutoLISP Blueprint란?

AutoLISP Blueprint는 AutoLISP/Visual LISP 코드를 시각적으로 설계하고 생성할 수 있는 혁신적인 도구입니다. 복잡한 LISP 구문을 직접 작성하는 대신, 캔버스 위에 함수를 나타내는 '노드(Node)'를 배치하고, 데이터 흐름을 '연결(Connection)'하여 프로그래밍 로직을 구축합니다. 이 시각적 다이어그램은 실시간으로 유효한 AutoLISP 코드로 변환됩니다.

이 방식은 코드의 구조를 한눈에 파악하기 쉽게 만들어주며, 구문 오류를 줄이고 개발 속도를 크게 향상시킵니다. 특히 LISP에 익숙하지 않거나 시각적인 프로그래밍 방식을 선호하는 사용자에게 매우 유용합니다.

### 주요 기능

*   **시각적 프로그래밍:** 드래그 앤 드롭 인터페이스로 LISP 함수(노드)를 배치하고 연결하여 로직을 설계합니다.
*   **실시간 코드 생성:** 캔버스에서 만드는 다이어그램이 즉시 AutoLISP 코드로 변환되어 오른쪽 패널에 표시됩니다.
*   **방대한 함수 라이브러리:** 수백 개의 내장 AutoLISP, Visual LISP, Express Tools 함수를 검색하고 사용할 수 있습니다.
*   **AI 기반 코드 생성:** 자연어 설명만으로 LISP 코드를 자동으로 생성합니다. (개인 API 키 필요)
*   **기존 LISP 파일 가져오기:** 작성된 `.lsp` 파일을 불러와 시각적 다이어그램으로 자동 변환합니다.
*   **그룹 이동:** `Shift` 또는 `Ctrl` 키를 누른 채 노드를 드래그하면 연결된 노드 그룹을 함께 이동시켜 레이아웃을 편리하게 관리할 수 있습니다.

---

## 2. 초기 설정: API 키 등록

'Generate with AI'와 같은 인공지능 기반 기능을 사용하려면 **사용자 개인의 Google AI API 키**가 필요합니다.

API 키를 등록하는 것은 보안, 비용 및 사용량 관리를 사용자 개인이 직접 하도록 하여 서비스를 안전하고 안정적으로 운영하기 위함입니다. API 키는 서버로 전송되지 않고 사용자의 브라우저(localStorage)에만 안전하게 저장됩니다.

### API 키 설정 방법

1.  화면 우측 상단의 메뉴 바에서 **설정 아이콘(톱니바퀴 모양)**을 클릭합니다.
2.  'Settings' 팝업창이 나타나면, "Google AI Studio" 링크를 클릭하여 API 키를 발급받습니다. (Google 계정 필요)
3.  발급받은 API 키를 복사하여 'Google AI API Key' 입력 필드에 붙여넣습니다.
4.  **'Save'** 버튼을 눌러 키를 저장합니다. 이제 AI 관련 기능을 사용할 수 있습니다.

---

## 3. 인터페이스 둘러보기

### 메인 화면 구성

애플리케이션은 크게 세 부분으로 나뉩니다.

1.  **함수 라이브러리 (왼쪽):**
    *   사용 가능한 모든 LISP 함수가 카테고리별로 정리되어 있습니다.
    *   검색창을 이용해 원하는 함수를 빠르게 찾을 수 있습니다.
    *   함수 이름 옆의 `+` 버튼을 클릭하면 캔버스에 해당 함수 노드가 추가됩니다.

2.  **캔버스 (중앙):**
    *   프로그래밍 로직을 시각적으로 구현하는 주 작업 공간입니다.
    *   이곳에 노드를 배치하고 서로 연결하여 다이어그램을 만듭니다.

3.  **생성된 코드 미리보기 (오른쪽):**
    *   캔버스에 만든 다이어그램이 실시간으로 AutoLISP 코드로 변환되어 표시됩니다.
    *   캔버스에서 특정 노드를 선택하면, 코드 미리보기에서 해당 노드가 생성한 코드 부분이 하이라이트됩니다.

### 메뉴 바

화면 상단에는 파일 관리, 편집, AI 기능 등을 위한 메뉴가 있습니다.

*   **New:** 현재 캔버스를 비우고 새 다이어그램을 시작합니다.
*   **Save:** 현재 다이어그램을 `.lispbp` 파일 형식으로 저장합니다. (주의: LISP 코드가 아닌 다이어그램 구조를 저장합니다.)
*   **Load:** 저장된 `.lispbp` 파일을 불러와 캔버스를 대체합니다.
*   **Import:** 기존 캔버스에 `.lispbp` 파일을 추가로 불러옵니다. (기존 내용을 유지한 채 병합)
*   **Undo/Redo:** 이전 작업으로 되돌리거나 다시 실행합니다.
*   **Import LISP:** 기존 `.lsp` 파일을 분석하여 시각적 다이어그램으로 자동 변환합니다.
*   **Generate with AI:** 자연어 설명을 입력하여 AI가 코드를 생성하도록 합니다. (API 키 필요)
*   **Settings (톱니바퀴 아이콘):** Google AI API 키를 입력하고 관리하는 설정창을 엽니다.

### 상태 바

화면 하단에는 유용한 정보가 표시됩니다.

*   **마우스 좌표 (X, Y):** 캔버스 내의 마우스 커서 위치를 보여줍니다.
*   **확대/축소 (Zoom):** 현재 캔버스의 확대/축소 비율을 표시합니다.
*   **상태 메시지:** 파일 파싱 중일 때 진행 상황을 알리거나, 노드/입력 필드에 마우스를 올리면 관련 설명을 표시합니다.

---

## 4. 핵심 개념: 다이어그램 제작

### 노드(Nodes)

**노드**는 하나의 LISP 함수 호출을 시각적으로 표현한 블록입니다.

*   **노드 추가:** 왼쪽 함수 라이브러리에서 원하는 함수의 `+` 버튼을 클릭합니다.

*   **노드의 구조:**
    *   **제목 표시줄:** 함수의 이름이 표시됩니다. 드래그하여 노드를 이동할 수 있습니다. 오른쪽에는 노드 색상을 변경하는 **붓 아이콘**과 노드를 삭제하는 **휴지통 아이콘**이 있습니다.
    *   **입력 소켓 (Input Sockets):** 노드의 왼쪽에 있는 동그라미. 함수의 인자(argument)를 의미합니다. 다른 노드의 출력값을 받거나, 옆의 입력 필드에 직접 값을 입력할 수 있습니다.
    *   **출력 소켓 (Output Sockets):** 노드의 오른쪽에 있는 동그라미. 함수의 반환값(return value)을 의미합니다. 이 값을 다른 노드의 입력으로 연결할 수 있습니다.
    *   **입력 필드 (Input Fields):** 입력 소켓 옆에 있는 텍스트 상자. 여기에 숫자나 문자열 같은 고정된 값을 직접 입력할 수 있습니다. (예: `getstring` 함수의 프롬프트 메시지)
    *   **동적 입력 (Dynamic Inputs):** `progn`, `+`, `command` 노드처럼 여러 개의 인자를 가질 수 있는 경우, `+` 버튼을 눌러 입력을 동적으로 추가할 수 있습니다.

### 연결(Connections)

**연결**은 노드와 노드 사이를 잇는 선으로, 데이터의 흐름을 나타냅니다. 한 노드의 출력(반환값)을 다른 노드의 입력(인자)으로 전달하는 것을 의미합니다.

*   **연결 생성:**
    1.  한 노드의 **출력 소켓**을 마우스로 클릭합니다.
    2.  마우스를 누른 상태로 다른 노드의 **입력 소켓**까지 드래그한 후 놓습니다.

*   **연결 호환성:**
    *   연결이 가능한 경우(데이터 타입이 호환될 때), 입력 소켓이 **녹색**으로 빛납니다.
    *   연결이 불가능한 경우, 입력 소켓이 **빨간색**으로 빛납니다.

*   **연결 관리:**
    *   **선택:** 연결선을 클릭하면 빨간색으로 변하며 선택됩니다.
    *   **삭제:** 연결선을 선택한 후 키보드의 `Delete` 또는 `Backspace` 키를 누릅니다.
    *   **수정:** 연결선의 끝점(입력 소켓 쪽)을 드래그하여 다른 입력 소켓으로 옮길 수 있습니다.

---

## 5. 캔버스 사용법

### 탐색

*   **이동 (Pan):**
    *   마우스 **가운데 버튼**을 누른 상태로 드래그합니다.
    *   또는, `Alt` 키를 누른 상태로 **왼쪽 버튼**을 드래그합니다.
*   **확대/축소 (Zoom):** 마우스 휠을 위아래로 스크롤합니다.

### 노드 조작

*   **이동:** 노드의 제목 표시줄을 드래그하여 이동합니다. 이동 시 보조 키를 사용하여 동작을 변경할 수 있습니다.
    *   **기본 드래그:** 선택한 노드만 이동합니다.
    *   **`Ctrl` + 드래그:** 선택한 노드와 그 노드에 입력을 제공하는 **포함된 모든 노드들**(해당 노드를 구성하는 모든 상위 노드)을 함께 이동합니다. `defun`이나 `progn`과 같은 컨테이너 노드와 그 내용을 하나의 그룹으로 옮길 때 매우 유용합니다.
    *   **`Shift` + 드래그:** 선택한 노드와 **연결된 모든 노드**(부모, 자식 관계없이 선으로 이어진 전체 그룹)를 함께 이동합니다. 복잡한 다이어그램의 레이아웃을 크게 재구성할 때 매우 유용합니다.
*   **선택:** 노드를 클릭하면 파란색 테두리가 생기며 선택됩니다.
*   **복사/붙여넣기:** 선택된 노드를 `Ctrl+C` (또는 `Cmd+C`)로 복사하고, `Ctrl+V` (또는 `Cmd+V`)로 붙여넣을 수 있습니다.
*   **삭제:** 노드 제목 표시줄의 휴지통 아이콘을 클릭합니다.

---

## 6. 주요 기능 활용하기

### AI를 이용한 코드 생성 (Generate with AI)

자연어로 원하는 기능을 설명하면 AI가 자동으로 LISP 코드를 만들어줍니다. **이 기능을 사용하려면 먼저 API 키를 등록해야 합니다.**

1.  상단 메뉴 바에서 **'Generate with AI'** 버튼을 클릭합니다.
2.  나타난 팝업창에 만들고 싶은 기능을 상세히 설명합니다. (예: "사용자에게 중심점과 반지름을 입력받아 원을 그리는 'c:DrawCircle'이라는 명령어를 만들어줘.")
3.  **'Generate Code'** 버튼을 누르면 AI가 분석 후 `code-block` 노드 안에 LISP 코드를 생성합니다.
4.  생성된 `code-block` 노드 상단의 **아이콘(Generate Diagram from Code)**을 클릭하면 해당 코드를 다이어그램으로 변환할 수 있습니다.

### 파일 관리

*   **저장 (`.lispbp`):** 현재 작업 중인 다이어그램의 구조(노드 위치, 연결 상태, 입력값 등)를 저장합니다. AutoLISP 코드가 아닌, 시각적 설계도 자체를 저장하는 것입니다.
*   **불러오기 (`.lispbp`):** 저장된 다이어그램 파일을 불러옵니다. **주의: 현재 캔버스의 모든 내용은 덮어씌워집니다.**
*   **가져오기 (`.lispbp`):** 저장된 다이어그램을 **현재 캔버스에 추가**합니다. 기존 내용을 지우지 않고 여러 다이어그램을 하나로 합칠 때 유용합니다. 가져온 다이어그램은 기존 요소와 겹치지 않도록 적절한 위치에 배치됩니다.
*   **LISP 파일 가져오기 (Import LISP):** 이미 작성된 `.lsp` 파일을 시각적 다이어그램으로 변환할 수 있습니다.
    1.  상단 메뉴 바에서 **'Import LISP'** 버튼을 클릭합니다.
    2.  변환하고 싶은 `.lsp` 파일을 선택합니다.
    3.  내장된 파서가 파일을 분석하여 캔버스에 해당하는 노드와 연결을 생성합니다.
    4.  참고용으로, 원본 코드가 담긴 `code-block` 노드가 캔버스 좌측에 함께 생성됩니다.

### 특수 노드 상세 가이드

*   **`defun` / `defun-q`:** 함수를 정의하는 노드입니다.
    *   `sym` 입력 필드에 함수 이름(`c:MyCommand`)을 입력합니다.
    *   **ARGUMENTS** 섹션의 `+` 버튼으로 함수 인자를 추가할 수 있습니다.
    *   **EXPRESSIONS** 섹션의 `+` 버튼으로 함수 본문에 실행될 표현식을 추가할 수 있습니다. 다른 노드의 출력을 이곳에 연결하여 함수의 로직을 구성합니다.
    *   표현식 입력의 왼쪽에 있는 `label` 필드에 변수명을 입력하면, 연결된 노드의 결과가 해당 변수에 할당됩니다(즉, `(setq var_name ...)` 코드가 생성됩니다).

*   **`progn`:** 여러 표현식을 순차적으로 실행해야 할 때 사용합니다. `defun` 노드와 유사하게 `+` 버튼으로 실행할 표현식을 추가하고, `label`을 이용해 중간 결과를 변수에 저장할 수 있습니다.

*   **`cond`:** 조건 분기를 만듭니다. `+` 버튼을 누르면 `(테스트 표현식 / 결과 표현식)` 한 쌍의 입력이 추가됩니다. 각 입력은 다른 노드와 연결하거나 직접 값을 입력할 수 있습니다.

*   **`code-block`:** 정해진 함수 외에 자유로운 LISP 코드를 직접 작성하고 싶을 때 사용합니다. 이 노드의 내용은 그대로 최종 코드에 삽입됩니다. 노드 우측 하단을 드래그하여 크기를 조절할 수 있습니다.

*   **`note`:** 코드 생성에 영향을 주지 않는 주석용 노드입니다. 다이어그램에 설명을 추가할 때 사용합니다.

*   **`caller`:** 라이브러리에 없거나 사용자가 직접 정의한 함수를 호출할 때 사용합니다. `function_name` 필드에 호출할 함수 이름을 입력하고, `+` 버튼으로 필요한 인자를 추가하여 연결할 수 있습니다.

---

## 7. 예제: 간단한 원 그리기 명령어 만들기

1.  **함수 정의:** `defun` 노드를 추가하고, `sym` 입력 필드에 `c:MyCircle`이라고 입력합니다.
2.  **중심점 입력받기:** `getpoint` 노드를 추가합니다. `msg` 입력 필드에 `"원의 중심점을 선택하세요:"` 라고 입력합니다.
3.  **반지름 입력받기:** `getreal` 노드를 추가합니다. `msg` 입력 필드에 `"반지름을 입력하세요:"` 라고 입력합니다.
4.  **명령어 실행:** `command` 노드를 추가합니다.
    *   첫 번째 `command_name` 입력 필드에 `"._CIRCLE"`이라고 입력합니다.
    *   `+` 버튼을 눌러 동적 입력을 두 개 추가합니다.
5.  **노드 연결:**
    *   `getpoint` 노드의 출력 소켓을 `command` 노드의 첫 번째 동적 입력 소켓으로 연결합니다.
    *   `getreal` 노드의 출력 소켓을 `command` 노드의 두 번째 동적 입력 소켓으로 연결합니다.
    *   `command` 노드의 출력 소켓을 `defun` 노드의 **EXPRESSIONS** 입력 소켓으로 연결합니다.
6.  **코드 확인:** 오른쪽 코드 미리보기 패널에 다음과 같은 코드가 생성된 것을 확인합니다.

    ```lisp
    (defun c:MyCircle ()
      (command "._CIRCLE" (getpoint "원의 중심점을 선택하세요:") (getreal "반지름을 입력하세요:"))
      (princ)
    )
    ```

7.  이제 코드를 복사하여 AutoCAD에서 사용할 수 있습니다!

---

## 8. 자주 묻는 질문 (FAQ)

*   **Q: 노드를 연결하려는데 소켓이 빨갛게 변해요.**
    *   A: 두 소켓의 데이터 타입이 호환되지 않기 때문입니다. 예를 들어, 숫자를 반환하는 함수의 출력을 문자열을 필요로 하는 입력에 연결할 수 없습니다. 각 소켓에 마우스를 올리면 `title` 툴팁으로 데이터 타입을 확인할 수 있습니다.

*   **Q: 함수 내에서 사용할 지역 변수(local variable)는 어떻게 만드나요?**
    *   A: `defun` 이나 `progn`과 같은 블록 노드의 동적 입력(Expression)에 있는 **`label`** 필드를 사용하세요. 여기에 변수 이름을 입력하면, 해당 입력에 연결된 노드의 결과가 그 변수에 `setq`로 할당됩니다. `defun` 노드에서 사용된 모든 `setq` 변수들은 자동으로 지역 변수로 선언됩니다.

*   **Q: 'Import LISP' 기능으로 불러온 다이어그램이 완벽하지 않아요.**
    *   A: LISP 코드 파서는 매우 강력하지만 100% 완벽하지 않을 수 있습니다. 복잡하거나 비표준적인 코드의 경우 일부 로직이 잘못 해석될 수 있습니다. 함께 생성된 `code-block` 노드의 원본 코드를 참고하여 다이어그램을 직접 수정해주세요.

*   **Q: 라이브러리에 없는 함수를 사용하고 싶어요.**
    *   A: `addLispFunc.md` 파일을 참고하여 라이브러리에 직접 새로운 함수를 추가할 수 있습니다. LISP 파일을 가져올 때(Import LISP) 라이브러리에 없는 함수는 **`caller` 노드**로 변환됩니다. 이 노드는 일반적으로 사용자가 직접 정의한 함수(custom defun)를 호출하는 경우에 해당하므로, 함수 이름이 올바른지 확인하고 필요에 따라 다이어그램을 수정하세요.
